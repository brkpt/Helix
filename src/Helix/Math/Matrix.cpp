#include <Math.h>
#include "Matrix.h"

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3::Matrix3x3()
{
	SetIdentity();
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3::Matrix3x3(const Helix::Matrix3x3 &other)
{
	for(int i=0; i<9; i++)
		e[i] = other.e[i];
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3::Matrix3x3(const Helix::Vector3 &r1, const Helix::Vector3 &r2, const Helix::Vector3 &r3)
{
	r[0][0] = r1.x;
	r[0][1] = r1.y;
	r[0][2] = r1.z;

	r[1][0] = r2.x;
	r[1][1] = r2.y;
	r[1][2] = r2.z;

	r[2][0] = r3.x;
	r[2][1] = r3.y;
	r[2][2] = r3.z;
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3 & Helix::Matrix3x3::SetIdentity()
{
	r[0][0] = 1.0f;
	r[0][1] = 0.0f;
	r[0][2] = 0.0f;

	r[1][0] = 0.0f;
	r[1][1] = 1.0f;
	r[1][2] = 0.0f;

	r[2][0] = 0.0f;
	r[2][1] = 0.0f;
	r[2][2] = 1.0f;

	return *this;
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3 & Helix::Matrix3x3::SetTransformXRotation(float radians)
{
	SetIdentity();
	r[1][1] = cos(radians);
	r[2][1] = sin(radians);
	r[1][2] = -1 * r[2][1];
	r[2][2] = r[1][1];
	return *this;
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3 & Helix::Matrix3x3::SetTransformYRotation(float radians)
{
	SetIdentity();
	r[0][0] = cos(radians);
	r[0][2] = sin(radians);
	r[2][0] = -1 * r[0][2];
	r[2][2] = r[0][0];
	return *this;
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3 & Helix::Matrix3x3::SetTransformZRotation(float radians)
{
	SetIdentity();
	r[0][0] = cos(radians);
	r[1][1] = r[0][0];
	r[1][0] = sin(radians);
	r[0][1] = -1.0f * r[1][0];
	return *this;
}

// ****************************************************************************
// ****************************************************************************
Helix::Matrix3x3 Helix::Matrix3x3::operator*(const Helix::Matrix3x3 &other)
{
	Helix::Matrix3x3 result;
	result.r[0][0] = r[0][0]*other.r[0][0] + r[0][1]*other.r[1][0] + r[0][2]*other.r[2][0];
	result.r[0][1] = r[0][0]*other.r[0][1] + r[0][1]*other.r[1][1] + r[0][2]*other.r[2][1];
	result.r[0][2] = r[0][0]*other.r[0][2] + r[0][1]*other.r[1][2] + r[0][2]*other.r[2][2];

	result.r[1][0] = r[1][0]*other.r[0][0] + r[1][1]*other.r[1][0] + r[1][2]*other.r[2][0];
	result.r[1][1] = r[1][0]*other.r[0][1] + r[1][1]*other.r[1][1] + r[1][2]*other.r[2][1];
	result.r[1][2] = r[1][0]*other.r[0][2] + r[1][1]*other.r[1][2] + r[1][2]*other.r[2][2];

	result.r[2][0] = r[2][0]*other.r[0][0] + r[2][1]*other.r[1][0] + r[2][2]*other.r[2][0];
	result.r[2][1] = r[2][0]*other.r[0][1] + r[2][1]*other.r[1][1] + r[2][2]*other.r[2][1];
	result.r[2][2] = r[2][0]*other.r[0][2] + r[2][1]*other.r[1][2] + r[2][2]*other.r[2][2];

	return result;
}
